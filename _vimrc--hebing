" Modeline and Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=78 foldlevel=0 foldmethod=marker:            "foldmarker={{{,}}} spell
"        shiftwidth tabstop softtabstop expandtab
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
"                                                                              "
"                       __   _ _ _ __ ___  _ __ ___                            "
"                       \ \ / / | '_ ` _ \| '__/ __|                           "
"                        \ V /| | | | | | | | | (__                            "
"                         \_/ |_|_| |_| |_|_|  \___|                           "
"                                                                              "
"                                                                              "
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
" }}}

" Environment {{{
    " Identify platform {{{
        "silent function! OSX()
        "    return has('macunix')
        "endfunction
        "silent function! LINUX()
        "    return has('unix') && !has('macunix') && !has('win32unix')
        "endfunction
        "silent function! WINDOWS()
        "    return  (has('win32') || has('win64'))
        "endfunction
        let g:darwin = has('mac')
        let g:osx = has('macunix')
        let g:linux  = has('unix') && !has('macunix') && !has('``win32unix')
        let g:windows = has('win32') || has('win64')
        "let mapleader      = ' '
        "let maplocalleader = ' '
        let $CONFIGDIR = fnamemodify($MYVIMRC, ':h')
        " let $CONFIGDIR = '~/.vim'
        set rtp^=$CONFIGDIR        "大多数ex命令不会扩展变量名，即，它们不接受表达式。“ set”不是扩展表达式（变量）的命令之一,但可以接受前缀为$的环境变量.
        "exe 'set rtp^=' . expand(g:VIMDIR)
        "将vim-plug存放目录放入rtp，+=添加在后面，^=添加在前面。"set rtp^=g:VIMDIR"这些不行，set不接受变不带任何前缀的变量
        " https://superuser.com/questions/806595/why-the-runtimepath-in-vim-cannot-be-set-as-a-variable

    " }}}

    " Basics {{{
        set nocompatible        " Must be first line
        if !g:windows
            set shell=/bin/sh
        endif
    " }}}

    " Windows Compatible {{{
        " On Windows, also use '.vim' instead of 'vimfiles'; this makes synchronization
        " across (heterogeneous) systems easier.
        if g:windows
          "set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
        endif
    " }}}
    
    " Arrow Key Fix {{{
        " https://github.com/spf13/spf13-vim/issues/780
        if &term[:4] == "xterm" || &term[:5] == 'screen' || &term[:3] == 'rxvt'
            inoremap <silent> <C-[>OC <RIGHT>
        endif
    " }}}

" }}}

" Environment {{{
    " form .vimrc.bundles

    " Basics {{{
        set nocompatible        " Must be first line
    " }}}

    " Windows Compatible {{{
        " On Windows, also use '.vim' instead of 'vimfiles'; this makes synchronization
        " across (heterogeneous) systems easier.
        if has('win32') || has('win64')
          "set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after

          " Be nice and check for multi_byte even if the config requires
          " multi_byte support most of the time
          if has("multi_byte")
            " Windows cmd.exe still uses cp850. If Windows ever moved to
            " Powershell as the primary terminal, this would be utf-8
            set termencoding=utf-8                 "cp850
            " Let Vim use utf-8 internally, because many scripts require this
            set encoding=utf-8
            setglobal fileencoding=utf-8
            " Windows has traditionally used cp1252, so it's probably wise to
            " fallback into cp1252 instead of eg. iso-8859-15.
            " Newer Windows files might contain utf-8 or utf-16 LE so we might
            " want to try them first.
            set fileencodings=ucs-bom,utf-8,utf-16le,cp1252,iso-8859-15
            "set fileencodings=ucs-bom,utf-8,chinese,latin1
          endif
          set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace
        endif
    " }}}
"    source ~/vimrc/nonascii.vim
"突出/高亮显示非ASCII字符
"https://stackoverflow.com/questions/26116926/why-dont-the-syntax-match-plus-highlight-commands-work
"https://stackoverflow.com/questions/27682324/set-item-to-higher-highlight-priority-on-vim/27687580#27687580
" \v"\w+"/匹配""内

"highlight nonASCII guifg=white guibg=red       "定义一个名为nonASCII的高亮组
"highlight link nonASCII ErrorMsg                "为已有的高亮分组起别名，只需要将新的分组连接到已有的分组即可。https://juejin.im/post/59314d110ce4630057f9f9f1
autocmd BufWrite,BufEnter,BufRead _vimrc,*.vim syntax match ErrorMsg "[^\x00-\x7F]"                              "这两句同效果。尾部加containedin=ALL，注释中也匹配。
"autocmd BufWrite,BufEnter,BufRead * :call matchadd('Error', '\v%(^.{-}".{-})@<![^\x00-\x7F]')        "这两句同效果

function HighlightNonAsciiOff()
    echom "Setting non-ascii highlight off"
    syn clear ErrorMsg
    let g:is_non_ascii_on=0
endfunction
function HighlightNonAsciiOn()
    echom "Setting non-ascii highlight on"
    syntax match ErrorMsg "[^\x00-\x7F]" containedin=ALL
    let g:is_non_ascii_on=1
endfunction
function ToggleHighlightNonascii()
    if g:is_non_ascii_on == 1 | call HighlightNonAsciiOff() | else |  call HighlightNonAsciiOn() | endif
endfunction
let g:is_non_ascii_on=0
nnoremap <leader>l :call ToggleHighlightNonascii()<CR>

"https://stackoverflow.com/questions/16987362/how-to-get-vim-to-highlight-non-ascii-characters/16987522
"function! NonPrintable()
"   setlocal enc=utf8
"   if search('\v%(^.{-}".{-})@<![^\x00-\x7F]') != 0
"     call matchadd('Error', '\v%(^.{-}".{-})@<![^\x00-\x7F]')
"     echo 'Non printable characters in text'
"   else
"     setlocal enc=latin1
"     echo 'All characters are printable'
"   endif
"endfunction
"autocmd BufWritePre * :call NonPrintable()


" }}}

" Bundles {{{
"    source ~/vimrc/1-plugins.vim
"*****************************************************************************
"" Plug install packages
"*****************************************************************************
"if empty(glob('~/.vim/autoload/plug.vim'))
"    silent exe "!curl -fLo ".$HOME."/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
"    if filereadable(expand("~/.vim/autoload/plug.vim"))
"        source $MYVIMRC | autocmd VimEnter * PlugInstall --sync
"    else
"        echo "vim-plug未安装成功"
"        finish
"   endif
"endif

"*****************************************************************************
"" Vim-Plug core   https://github.com/editor-bootstrap/vim-bootstrap/blob/master/vim_template/vimrc
"*****************************************************************************
let vimplug_exists=expand($CONFIGDIR.'/autoload/plug.vim')
if has('win32')&&!has('win64')
    let curl_exists=expand('C:\Windows\Sysnative\curl.exe')
else
    let curl_exists=expand('curl')
endif

if !filereadable(vimplug_exists)
    if !executable(curl_exists)
        echoerr "You have to install curl or first install vim-plug yourself!"
        execute "q!"
    endif
    echo "Installing Vim-Plug..."
    echo ""
    silent exec "!"curl_exists" -fLo " . shellescape(vimplug_exists) . " --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
    if filereadable(vimplug_exists)
        let g:not_finish_vimplug = "yes"
        autocmd VimEnter * PlugInstall --sync
    else
        echo "vim-plug未安装成功"
        finish
    endif
endif

let plugdir=expand($CONFIGDIR.'/plugged')
" Required:
call plug#begin(plugdir)                         "括号内的插件存放目录，vim-plig会自动将其放入rtp。
"*****************************************************************************
"" Plug install packages
"*****************************************************************************
"Plug 'junegunn/vim-plug'                        "If you need Vim help for vim-plug itself (e.g. :help plug-options)
"Plug 'MarcWeber/vim-addon-mw-utils'
"Plug 'tomtom/tlib_vim'
if executable('ag')
    Plug 'mileszs/ack.vim'
    let g:ackprg = 'ag --nogroup --nocolor --column --smart-case'
elseif executable('ack-grep')
    let g:ackprg="ack-grep -H --nocolor --nogroup --column"
    Plug 'mileszs/ack.vim'
elseif executable('ack')
    Plug 'mileszs/ack.vim'
endif
Plug 'yianwillis/vimcdoc'                        "中文帮助
Plug 'mhinz/vim-startify'
Plug 'mbbill/desertEx'                           "colorscheme
Plug 'tomasr/molokai'                            "colorscheme
Plug 'altercation/vim-colors-solarized'          "colorscheme
Plug 'Yggdroot/indentLine'                       "显示缩进指示线
let g:indentLine_color_gui = '#A4E57E'
Plug 'liuchengxu/vim-which-key'
Plug 'haya14busa/incsearch.vim'                  "内置incsearch得改进
Plug 'vim-airline/vim-airline'                   "状态栏
Plug 'vim-airline/vim-airline-themes'            "状态栏主题
Plug 'gko/vim-coloresque'                        "颜色预览
Plug 'luochen1990/rainbow'                       "彩虹括号
Plug 'jiangmiao/auto-pairs'                      "自动配对
Plug 'tpope/vim-surround'                        "about "surroundings",关于周围环境：()、[]、“”、XML标记等，轻松地成对删除ds，更改cs和添加ys此类环境。
Plug 'tpope/vim-repeat'                          ".命令重复surround.vim、speeddating.vim、unimpaired.vim、vim-easyclip等的操作。
Plug 'jdpxiaoming/winmanager'                    "winmanager有3个插件：winmanager.vim、winfileexplorer.vim、wintagexplorer.vim。winmanager负责界面布局；
                                                 "winfileexplorer是改良的Explorer(即现在的netrw)，负责浏览文件；wintagexplorer负责浏览标志列表，用taglist插件代替
Plug 'vim-scripts/taglist.vim'                   "wintagexplorer.vim – winmanager提供的tag插件，用处不大,用taglist.vim替换。
Plug 'jlanzarotta/bufexplorer'                   "winmanager配合bufexplorer，用于浏览buffer
Plug 'whatot/gtags-cscope.vim'                   "包含gtags-cscope.vim和gtags.vim
Plug 'tpope/vim-scriptease'
Plug 'kien/ctrlp.vim'                            "终端则使用FZF如果gvim使用CtrlP
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'ryanoasis/vim-devicons'
" Initialize plugin system
call plug#end()

" Automatically install missing plugins on startup
autocmd VimEnter *
  \  if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  \|   PlugInstall --sync | q
  \| endif

"" Vundle.vim插件
"if !isdirectory(expand("~/.vim/bundle/Vundle.vim"))
"    silent exe "!cd ".$HOME
"    silent exe "!git clone https://github.com/VundleVim/Vundle.vim.git " . $HOME . "/.vim/bundle/Vundle.vim"
"    source $MYVIMRC | autocmd VimEnter * PluginInstall
"    if !isdirectory(expand("~/.vim/bundle/Vundle.vim"))
"        echo "Vundle.vim插件未安装成功"
"   endif
"else
"    set nocompatible              " be iMproved, required
"    filetype off                  " required
"
"    " set the runtime path to include Vundle and initialize
"    set rtp+=~/.vim/bundle/Vundle.vim
"    call vundle#begin('~/.vim/bundle')
"    " let Vundle manage Vundle, required
"    Plugin 'VundleVim/Vundle.vim'
"    Plugin 'vim-airline/vim-airline'                   "状态栏
"    Plugin 'vim-airline/vim-airline-themes'            "状态栏主题
"    Plugin 'gko/vim-coloresque'                        "颜色预览
"    Plugin 'luochen1990/rainbow'                       "彩虹括号
"    Plugin 'jiangmiao/auto-pairs'                      "自动配对
"    Plugin 'tpope/vim-surround'                        "about "surroundings",关于周围环境：()、[]、“”、XML标记等，轻松地成对删除ds，更改cs和添加ys此类环境。
"    Plugin 'tpope/vim-repeat'                          ".命令重复surround.vim、speeddating.vim、unimpaired.vim、vim-easyclip等的操作。
"    Plugin 'jdpxiaoming/winmanager'                    "winmanager有3个插件：winmanager.vim、winfileexplorer.vim、wintagexplorer.vim。winmanager负责界面布局；
"                                                     "winfileexplorer是改良的Explorer(即现在的netrw)，负责浏览文件；wintagexplorer负责浏览标志列表，用taglist插件代替
"    Plugin 'vim-scripts/taglist.vim'                   "wintagexplorer.vim – winmanager提供的tag插件，用处不大,用taglist.vim替换。
"    Plugin 'jlanzarotta/bufexplorer'                   "winmanager配合bufexplorer，用于浏览buffer
"    Plugin 'whatot/gtags-cscope.vim'                   "包含gtags-cscope.vim和gtags.vim
"    Plugin 'tpope/vim-scriptease'
"    Plugin 'kien/ctrlp.vim'                            "终端则使用FZF如果gvim使用CtrlP
"    Plugin 'junegunn/fzf'
"    Plugin 'junegunn/fzf.vim'
"    "Plugin 'Yggdroot/LeaderF', { 'do': '.\install.bat' }
"    "Plugin 'Yggdroot/LeaderF'
"
"    " All of your Plugins must be added before the following line
"    call vundle#end()            " required
"    filetype plugin indent on    " required
"    " To ignore plugin indent changes, instead use:
"    "filetype plugin on
"    "
"    " Brief help
"    " :PluginList       - lists configured plugins
"    " :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
"    " :PluginSearch foo - searches for foo; append `!` to refresh local cache
"    " :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"    "
"    " see :h vundle for more details or wiki for FAQ
"    " Put your non-Plugin stuff after this line
"endif
" }}}

" General {{{

    set background=dark         " Assume a dark background

    " Allow to trigger background
    function! ToggleBG()
        let s:tbg = &background
        " Inversion
        if s:tbg == "dark"
            set background=light
        else
            set background=dark
        endif
    endfunction
    noremap <leader>bg :call ToggleBG()<CR>

    " if !has('gui')
        "set term=$TERM          " Make arrow and other keys work
    " endif
    filetype plugin indent on   " Automatically detect file types.
    "syntax on                   " Syntax highlighting
    set mouse=a                 " Automatically enable mouse usage
    set mousehide               " Hide the mouse cursor while typing
    scriptencoding utf-8

    if has('clipboard')
        if has('unnamedplus')  " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else         " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    " Most prefer to automatically switch to the current file directory when
    " a new buffer is opened; to prevent this behavior, add the following to
    " your .vimrc.before.local file:
    "   let g:spf13_no_autochdir = 1
    if !exists('g:spf13_no_autochdir')
        autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
        " Always switch to the current file directory
    endif

    "set autowrite                       " Automatically write a file when leaving a modified buffer
    set shortmess+=filmnrxoOtT          " Abbrev. of messages (avoids 'hit enter')
    set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
    set virtualedit=onemore             " Allow for cursor beyond last character
    set history=1000                    " Store a ton of history (default is 20)
    "set spell                           " Spell checking on
    set hidden                          " Allow buffer switching without saving
    set iskeyword-=.                    " '.' is an end of word designator
    set iskeyword-=#                    " '#' is an end of word designator
    set iskeyword-=-                    " '-' is an end of word designator

    " Instead of reverting the cursor to the last position in the buffer, we
    " set it to the first line when editing a git commit message
    au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

    " http://vim.wikia.com/wiki/Restore_cursor_to_file_position_in_previous_editing_session
    " Restore cursor to file position in previous editing session
    " To disable this, add the following to your .vimrc.before.local file:
    "   let g:spf13_no_restore_cursor = 1
    if !exists('g:spf13_no_restore_cursor')
        function! ResCur()
            if line("'\"") <= line("$")
                silent! normal! g`"
                return 1
            endif
        endfunction

        augroup resCur
            autocmd!
            autocmd BufWinEnter * call ResCur()
        augroup END
    endif

    " Setting up the directories {{{
        " backup、writeback、upundofile、swapfile
        if !isdirectory(expand('$HOME/.vim/temp/backup'))         " 该文件夹不存在，保存文件时会报“E509 :无法创建备份文件(请加!强制执)"
            "silent exe "!cd ". $HOME."\\.vim"
            "silent exe "!mkdir ".$HOME."\\.vim\\temp\\backup"    “ silent exe "!mkdir ".$HOME."/.vim/backup" 这样cmd会报命令语法错误。
            silent exe "!mkdir ". shellescape(expand("$HOME/.vim/temp/backup"))
            " expand展开变量、shellescape转义特殊字符。
        endif
        if !isdirectory(expand('$HOME/.vim/temp/undo'))
            silent exe "!mkdir ". shellescape(expand("$HOME/.vim/temp/undo"))
        endif
        if !isdirectory(expand('$HOME/.vim/temp/swap'))
            silent exe "!mkdir ". shellescape(expand("$HOME/.vim/temp/swap"))
        endif

        set backup    " Backups are nice ...
        set backupdir=~/.vim/temp/backup                                  " 结尾有//，下一句就不起作用。
        autocmd BufWritePre * let &backupext = strftime(".%m-%d-%H-%M")   " Keep more backups for one file
        set directory=~/.vim/temp/swap//
        set undodir=~/.vim/temp/undo//   "设置备份文件、交换文件、操作历史文件的保存位置。结尾的//表示生成的文件名带有绝对路径，路径中用%替换目录分隔符，这样可以防止文件重名。

        if has('persistent_undo')
            set undofile                " So is persistent undo ...
            set undolevels=1000         " Maximum number of changes that can be undone
            set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
        endif

        " To disable views add the following to your .vimrc.before.local file:
        "   let g:spf13_no_views = 1
        if !exists('g:spf13_no_views')
            " Add exclusions to mkview and loadview
            " eg: *.*, svn-commit.tmp
            let g:skipview_files = [
                \ '\[example pattern\]'
                \ ]
        endif
    " }}}

" }}}

" Vim UI {{{
    colorscheme industry            "彩色主题
    if filereadable(expand(plugdir."/desertEx/colors/desertEx.vim")) | colorscheme desertEx | endif
    "if filereadable(expand(plugdir."/monokai/colors/monokai.vim")) | colorscheme monokai | endif
    if !exists('g:overridezRpf13_bundles') && filereadable(expand(plugdir."/vim-colors-solarized/colors/solarized.vim"))
        let g:solarized_termcolors=256
        let g:solarized_termtrans=1
        let g:solarized_contrast="normal"
        let g:solarized_visibility="normal"
    "    color solarized             " Load a colorscheme
    endif
    "execute "set colorcolumn=" . join(range(120,335), ',')
    let &colorcolumn="120,".join(range(122,999),",")      "垂直参考线
    "let &colorcolumn="120"
    "highlight ColorColumn ctermbg=0 guibg=#222128         "#2E2E2E

    set tabpagemax=15               " Only show 15 tabs
    set showmode                    " Display the current mode

    set cursorline                  " Highlight current line
    hi CursorLine guibg=#333333

    "highlight clear SignColumn      " SignColumn should match background
    "highlight clear LineNr          " Current line number row will have same background color in relative mode
    "highlight clear CursorLineNr    " Remove highlight color from current line number
    
    if has('cmdline_info')
        set ruler                   " Show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
        set showcmd                 " Show partial commands in status line and
                                    " Selected characters/lines in visual mode
    endif

"    source ~/vimrc/6-statusline.vim
if has('statusline')
    set laststatus=2

    " Broken down into easily includeable segments
    "set statusline=%<%f\                     " Filename
    "set statusline+=%w%h%m%r                 " Options
    "if !exists('g:override_spf13_bundles')
    "    set statusline+=%{fugitive#statusline()} " Git Hotness
    "endif
    "set statusline+=\ [%{&ff}/%Y]            " Filetype
    "set statusline+=\ [%{getcwd()}]          " Current dir
    "set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info

    function! StatuslineMode() abort
      return { 'n': 'NORMAL', 'v': 'VISUAL',   'i': 'INSERT',  'R': 'REPLACE',
             \ 's': 'SELECT', 't': 'TERMINAL', 'c': 'COMMAND', '!': 'SHELL',
        \ }[mode()]
    endfunction

"        set statusline=\ [%{StatuslineMode()[mode()]}]
"        set statusline+=\ %{toupper(g:currentmode[mode()])}
"        set statusline+=\ [%F]▶[%{strlen(&fenc)?&fenc:'none'},%{&ff}%w%h%m%r%y%=[%{strftime(\"%H:%M\")}][L:%l/%L,C:%c][\ %P]

    " Status Line Custom
    let g:currentmode={
        \ 'n'  : 'Normal',
        \ 'no' : 'Normal·Operator Pending',
        \ 'v'  : 'Visual',
        \ 'V'  : 'V·Line',
        \ "\<C-V>" : 'V·Block',
        \ 's'  : 'Select',
        \ 'S'  : 'S·Line',
        \ "\<C-S>" : 'S·Block',
        \ 'i'  : 'Insert',
        \ 'R'  : 'Replace',
        \ 'Rv' : 'V·Replace',
        \ 'c'  : 'Command',
        \ 'cv' : 'Vim Ex',
        \ 'ce' : 'Ex',
        \ 'r'  : 'Prompt',
        \ 'rm' : 'More',
        \ 'r?' : 'Confirm',
        \ '!'  : 'Shell',
        \ 't'  : 'Terminal'
        \}

    function! FileSize()
      let bytes = getfsize(expand('%:p'))
      if (bytes >= 1024)
        let kbytes = bytes / 1024
      endif
      if (exists('kbytes') && kbytes >= 1000)
        let mbytes = kbytes / 1000
      endif

      if bytes <= 0
        return '0'
      endif

      if (exists('mbytes'))
        return mbytes . 'MB '
      elseif (exists('kbytes'))
        return kbytes . 'KB '
      else
        return bytes . 'B '
      endif
    endfunction

    function! ReadOnly()
      if &readonly || !&modifiable
        return ''
      else
        return ''
    endfunction

    set statusline=
    set statusline+=%3*\[%n]                                  "buffernr
    set statusline+=%0*\ %{toupper(g:currentmode[mode()])}\  " The current mode
    set statusline+=%2*\ %<%F\                                "File+path
    set statusline+=%2*%(%{ReadOnly()}%h%m%w%)\              "Modified? Readonly? Top/bot.
    set statusline+=%1*\ %y\                                  "FileType
    set statusline+=%2*\ %{''.(&fenc!=''?&fenc:&enc).''}      "Encoding
    set statusline+=%2*%{(&bomb?\",BOM\":\"\")}\            "Encoding2
    set statusline+=%1*\ %{&ff}\                              "FileFormat (dos/unix..) 
    set statusline+=%2*%=                                       "Rownumber/total (%)
    set statusline+=%8*\ [%{strftime(\"%H:%M\")}]\                  "Colnr
    set statusline+=%9*\ [%-3(%{FileSize()}%)]\                  " File size
    set statusline+=%8*\ [L%l/%L:C%c]\ 
    set statusline+=%9*\ [%P]\ 

    hi User1 ctermfg=007 ctermbg=239 guibg=#4e4e4e guifg=#adadad
    hi User2 ctermfg=007 ctermbg=236 guibg=#303030 guifg=#adadad
    hi User3 guifg=#292b00  guibg=#f4f597
    hi User4 guifg=#112605  guibg=#aefe7B
    hi User5 guifg=#051d00  guibg=#7dcc7d
    hi User7 guifg=#ffffff  guibg=#880c0e gui=bold
    hi User8 guifg=#ffffff  guibg=#5b7fbb
    hi User9 guifg=#ffffff  guibg=#810085

    au InsertEnter * hi statusline guifg=yellow guibg=black ctermfg=black ctermbg=magenta
    au InsertChange * hi statusline guifg=yellow guibg=black ctermfg=black ctermbg=magenta
    au InsertLeave * hi statusline guibg=black guifg=white

    "function! InsertStatuslineColor(mode)
    "if a:mode == 'i'
    "  hi statusline guifg=yellow
    "elseif a:mode == 'r'
    "  hi statusline guifg=blue
    "else
    "  hi statusline guifg=black
    "endif
    "endfunction
    "au InsertEnter * call InsertStatuslineColor(v:insertmode)
    "au InsertChange * call InsertStatuslineColor(v:insertmode)
    "au InsertLeave * hi statusline guibg=black guifg=white
    function! s:statusline_expr()
        "let mod = "%{&modified ? '[+] ' : !&modifiable ? '[x] ' : ''}"
        "let ro  = "%{&readonly ? '[RO] ' : ''}"
        "let ft  = "%{len(&filetype) ? '['.&filetype.'] ' : ''}"
        "let fug = "%{exists('g:loaded_fugitive') ? fugitive#statusline() : ''}"
        "let sep = ' %= '
        "let pos = ' %-12(%l : %c%V%) '
        "let pct = ' %P'
        "return '[%n] %F %<'.mod.ro.ft.fug.sep.pos.'%*'.pct
        
        let num  = "%3*\[%n]"                                  "buffernr
        let mode = "%0*\ %{toupper(g:currentmode[mode()])}\ "  "The current mode
        let file = "%2*\ %<%F\ %<"                               "File+path
        let modi = "%2*%(%{ReadOnly()}%h%m%w%)\ "              "Modified? Readonly? Top/bot.
        let ft   = "%1*\ %y\ "                                 "FileType
        let en   = "%2*\ %{''.(&fenc!=''?&fenc:&enc).''}"      "Encoding
        let bom  = "%2*%{(&bomb?\",BOM\":\"\")}\ "             "Encoding2
        let ff   = "%1*\ %{&ff}\ "                             "FileFormat (dos/unix..) 
        let sep  = '%2*%='                                     "Rownumber/total (%)
        let time = "%8*\ [%{strftime(\"%H:%M\")}]\ "           "Colnr
        let size = "%9*\ [%-3(%{FileSize()}%)]\ "              "File size
        let pos  = "%8*\ [L%l/%L:C%c]\ "
        let pct  = "%9*\ [%P]\ "
        return num.mode.file.modi.ft.en.bom.ff.sep.time.size.pos.pct
    endfunction
    let &statusline = s:statusline_expr()
endif


    set backspace=indent,eol,start  " Backspace for dummies
    set linespace=0                 " No extra spaces between rows
    set number                      " Line numbers on
    set showmatch                   " Show matching brackets/parenthesis
    set incsearch                   " Find as you type search
    set hlsearch                    " Highlight search terms
    set winminheight=0              " Windows can be 0 line high
    set ignorecase                  " Case insensitive search
    set smartcase                   " Case sensitive when uc present
    set wildmenu                    " Show list instead of just completing
    set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
    set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
    set scrolljump=5                " Lines to scroll when cursor leaves screen
    set scrolloff=3                 " Minimum lines to keep above and below cursor
    set foldenable                  " Auto fold code
    set list
    "set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

" }}}

" Formatting {{{

    set nowrap                      " Do not wrap long lines
    set autoindent                  " Indent at the same level of the previous line
    set shiftwidth=4                " Use indents of 4 spaces
    set expandtab                   " Tabs are spaces, not tabs
    set tabstop=4                   " An indentation every four columns
    set softtabstop=4               " Let backspace delete indent
    set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
    set splitright                  " Puts new vsplit windows to the right of the current
    set splitbelow                  " Puts new split windows to the bottom of the current
    "set matchpairs+=<:>             " Match, to be used with %
    set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)
    "set comments=sl:/*,mb:*,elx:*/  " auto format comment blocks
    " Remove trailing whitespaces and ^M chars
    " To disable the stripping of whitespace, add the following to your
    " .vimrc.before.local file:
    "   let g:spf13_keep_trailing_whitespace = 1
    autocmd FileType c,cpp,java,go,php,javascript,puppet,python,rust,twig,xml,yml,perl,sql autocmd BufWritePre <buffer> if !exists('g:spf13_keep_trailing_whitespace') | call StripTrailingWhitespace() | endif
    "autocmd FileType go autocmd BufWritePre <buffer> Fmt
    autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
    autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2
    " preceding line best in a plugin but here for now.

    autocmd BufNewFile,BufRead *.coffee set filetype=coffee

    " Workaround vim-commentary for Haskell
    autocmd FileType haskell setlocal commentstring=--\ %s
    " Workaround broken colour highlighting in Haskell
    autocmd FileType haskell,rust setlocal nospell

" }}}

" Key (re)Mappings {{{

    "https://vim.fandom.com/wiki/Find_in_files_within_Vim
    map <F4> :execute "vimgrep /" . expand("<cword>") . "/j **" <Bar> cw<CR>
" }}}

" Plugins {{{
"    source ~/vimrc/8-plugins-config.vim
" Modeline and Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=78 foldlevel=0 foldmethod=marker:            "foldmarker={{{,}}} spell
"        shiftwidth tabstop softtabstop expandtab
" }}}

" startify {{{
    let g:startify_custom_header = [
            \ '       _  __     _         __  ___         __     ___ ',
            \ '      / |/ /  __(_)_ _    /  |/  /__ _____/ /    |_  |',
            \ '     /    / |/ / /  ` \  / /|_/ / _ `/ __/ _ \  / __/ ',
            \ '    /_/|_/|___/_/_/_/_/ /_/  /_/\_,_/\__/_//_/ /____/ ',
            \]

    let g:startify_session_dir = $CONFIGDIR. '/session'


    let g:startify_lists = [
              \ { 'type': 'files',     'header': ['   Files']                        },
              \ { 'type': 'dir',       'header': ['   Current Directory '. getcwd()] },
              \ { 'type': 'sessions',  'header': ['   Sessions']                     },
              \ { 'type': 'bookmarks', 'header': ['   Bookmarks']                    },
              \ ]


    let g:startify_session_autoload = 1
    let g:startify_session_delete_buffers = 1
    let g:startify_change_to_vcs_root = 1
    let g:startify_fortune_use_unicode = 1
    let g:startify_session_persistence = 1

    let g:webdevicons_enable_startify = 1

"    function! StartifyEntryFormat()
"            return 'WebDevIconsGetFileTypeSymbol(absolute_path) ." ". entry_path'
"        endfunction

    let g:startify_bookmarks = [
                \ { 'c': '~/.config/i3/config' },
                \ { 'i': '~/.config/nvim/init.vim' },
                \ { 'z': '~/.zshrc' },
                \ '~/Blog',
                \ '~/Code',
                \ '~/Pics',
                \ ]

    let g:startify_enable_special = 0
" }}}

" vim-which-key {{{
    if isdirectory(expand(plugdir."/vim-which-key/"))
"        source ~/vimrc/5-which-key.vim
" Map leader to which_key
nnoremap <silent> <leader> :silent <c-u> :silent WhichKey '<Space>'<CR>
vnoremap <silent> <leader> :silent <c-u> :silent WhichKeyVisual '<Space>'<CR>

" Create map to add keys to
let g:which_key_map =  {}
" Define a separator
let g:which_key_sep = '→'
set timeoutlen=500


" Not a fan of floating windows for this
let g:which_key_use_floating_win = 0

" Change the colors if you want
highlight default link WhichKey          Operator
highlight default link WhichKeySeperator DiffAdded
highlight default link WhichKeyGroup     Identifier
highlight default link WhichKeyDesc      Function

" Hide status line
autocmd! FileType which_key
autocmd  FileType which_key set laststatus=0 noshowmode noruler
  \| autocmd BufLeave <buffer> set laststatus=2 noshowmode ruler


" Single mappings
let g:which_key_map['/'] = [ ':call Comment()'  , 'comment' ]
let g:which_key_map['.'] = [ ':e $MYVIMRC'                , 'open init' ]
let g:which_key_map[';'] = [ ':Commands'                  , 'commands' ]
let g:which_key_map['='] = [ '<C-W>='                     , 'balance windows' ]
let g:which_key_map[','] = [ 'Startify'                   , 'start screen' ]
let g:which_key_map['c'] = [ ':Codi!!'                    , 'virtual repl']
let g:which_key_map['d'] = [ ':bd'                        , 'delete buffer']
let g:which_key_map['e'] = [ ':CocCommand explorer'       , 'explorer' ]
let g:which_key_map['f'] = [ ':Files'                     , 'search files' ]
let g:which_key_map['h'] = [ '<C-W>s'                     , 'split below']
let g:which_key_map['q'] = [ 'q'                          , 'quit' ]
let g:which_key_map['r'] = [ ':RnvimrToggle'              , 'ranger' ]
let g:which_key_map['S'] = [ ':SSave'                     , 'save session' ]
let g:which_key_map['T'] = [ ':Rg'                        , 'search text' ]
let g:which_key_map['v'] = [ '<C-W>v'                     , 'split right']
let g:which_key_map['W'] = [ 'w'                          , 'write' ]
let g:which_key_map['z'] = [ 'Goyo'                       , 'zen' ]

" Group mappings

" a is for actions
let g:which_key_map.a = {
      \ 'name' : '+actions' ,
      \ 'c' : [':ColorizerToggle'        , 'colorizer'],
      \ 'e' : [':CocCommand explorer'    , 'explorer'],
      \ 'n' : [':set nonumber!'          , 'line-numbers'],
      \ 'r' : [':set norelativenumber!'  , 'relative line nums'],
      \ 's' : [':let @/ = ""'            , 'remove search highlight'],
      \ 't' : [':FloatermToggle'         , 'terminal'],
      \ 'v' : [':Vista!!'                , 'tag viewer'],
      \ }

" b is for buffer
let g:which_key_map.b = {
      \ 'name' : '+buffer' ,
      \ '1' : ['b1'        , 'buffer 1']        ,
      \ '2' : ['b2'        , 'buffer 2']        ,
      \ 'd' : ['bd'        , 'delete-buffer']   ,
      \ 'f' : ['bfirst'    , 'first-buffer']    ,
      \ 'h' : ['Startify'  , 'home-buffer']     ,
      \ 'l' : ['blast'     , 'last-buffer']     ,
      \ 'n' : ['bnext'     , 'next-buffer']     ,
      \ 'p' : ['bprevious' , 'previous-buffer'] ,
      \ '?' : ['Buffers'   , 'fzf-buffer']      ,
      \ }

" s is for search
let g:which_key_map.s = {
      \ 'name' : '+search' ,
      \ '/' : [':History/'              , 'history'],
      \ ';' : [':Commands'              , 'commands'],
      \ 'a' : [':Ag'                    , 'text Ag'],
      \ 'b' : [':BLines'                , 'current buffer'],
      \ 'B' : [':Buffers'               , 'open buffers'],
      \ 'c' : [':Commits'               , 'commits'],
      \ 'C' : [':BCommits'              , 'buffer commits'],
      \ 'f' : [':Files'                 , 'files'],
      \ 'g' : [':GFiles'                , 'git files'],
      \ 'G' : [':GFiles?'               , 'modified git files'],
      \ 'h' : [':History'               , 'file history'],
      \ 'H' : [':History:'              , 'command history'],
      \ 'l' : [':Lines'                 , 'lines'] ,
      \ 'm' : [':Marks'                 , 'marks'] ,
      \ 'M' : [':Maps'                  , 'normal maps'] ,
      \ 'p' : [':Helptags'              , 'help tags'] ,
      \ 'P' : [':Tags'                  , 'project tags'],
      \ 's' : [':CocList snippets'      , 'snippets'],
      \ 'S' : [':Colors'                , 'color schemes'],
      \ 't' : [':Rg'                    , 'text Rg'],
      \ 'T' : [':BTags'                 , 'buffer tags'],
      \ 'w' : [':Windows'               , 'search windows'],
      \ 'y' : [':Filetypes'             , 'file types'],
      \ 'z' : [':FZF'                   , 'FZF'],
      \ }
      " \ 's' : [':Snippets'     , 'snippets'],

" g is for git
let g:which_key_map.g = {
      \ 'name' : '+git' ,
      \ 'a' : [':Git add .'                        , 'add all'],
      \ 'A' : [':Git add %'                        , 'add current'],
      \ 'b' : [':Git blame'                        , 'blame'],
      \ 'B' : [':GBrowse'                          , 'browse'],
      \ 'c' : [':Git commit'                       , 'commit'],
      \ 'd' : [':Git diff'                         , 'diff'],
      \ 'D' : [':Gdiffsplit'                       , 'diff split'],
      \ 'g' : [':GGrep'                            , 'git grep'],
      \ 'G' : [':Gstatus'                          , 'status'],
      \ 'h' : [':GitGutterLineHighlightsToggle'    , 'highlight hunks'],
      \ 'H' : ['<Plug>(GitGutterPreviewHunk)'      , 'preview hunk'],
      \ 'j' : ['<Plug>(GitGutterNextHunk)'         , 'next hunk'],
      \ 'k' : ['<Plug>(GitGutterPrevHunk)'         , 'prev hunk'],
      \ 'l' : [':Git log'                          , 'log'],
      \ 'p' : [':Git push'                         , 'push'],
      \ 'P' : [':Git pull'                         , 'pull'],
      \ 'r' : [':GRemove'                          , 'remove'],
      \ 's' : ['<Plug>(GitGutterStageHunk)'        , 'stage hunk'],
      \ 't' : [':GitGutterSignsToggle'             , 'toggle signs'],
      \ 'u' : ['<Plug>(GitGutterUndoHunk)'         , 'undo hunk'],
      \ 'v' : [':GV'                               , 'view commits'],
      \ 'V' : [':GV!'                              , 'view buffer commits'],
      \ }

" l is for language server protocol
let g:which_key_map.l = {
      \ 'name' : '+lsp' ,
      \ '.' : [':CocConfig'                          , 'config'],
      \ ';' : ['<Plug>(coc-refactor)'                , 'refactor'],
      \ 'a' : ['<Plug>(coc-codeaction)'              , 'line action'],
      \ 'A' : ['<Plug>(coc-codeaction-selected)'     , 'selected action'],
      \ 'b' : [':CocNext'                            , 'next action'],
      \ 'B' : [':CocPrev'                            , 'prev action'],
      \ 'c' : [':CocList commands'                   , 'commands'],
      \ 'd' : ['<Plug>(coc-definition)'              , 'definition'],
      \ 'D' : ['<Plug>(coc-declaration)'             , 'declaration'],
      \ 'e' : [':CocList extensions'                 , 'extensions'],
      \ 'f' : ['<Plug>(coc-format-selected)'         , 'format selected'],
      \ 'F' : ['<Plug>(coc-format)'                  , 'format'],
      \ 'h' : ['<Plug>(coc-float-hide)'              , 'hide'],
      \ 'i' : ['<Plug>(coc-implementation)'          , 'implementation'],
      \ 'I' : [':CocList diagnostics'                , 'diagnostics'],
      \ 'j' : ['<Plug>(coc-float-jump)'              , 'float jump'],
      \ 'l' : ['<Plug>(coc-codelens-action)'         , 'code lens'],
      \ 'n' : ['<Plug>(coc-diagnostic-next)'         , 'next diagnostic'],
      \ 'N' : ['<Plug>(coc-diagnostic-next-error)'   , 'next error'],
      \ 'o' : ['<Plug>(coc-openlink)'                , 'open link'],
      \ 'O' : [':CocList outline'                    , 'outline'],
      \ 'p' : ['<Plug>(coc-diagnostic-prev)'         , 'prev diagnostic'],
      \ 'P' : ['<Plug>(coc-diagnostic-prev-error)'   , 'prev error'],
      \ 'q' : ['<Plug>(coc-fix-current)'             , 'quickfix'],
      \ 'r' : ['<Plug>(coc-rename)'                  , 'rename'],
      \ 'R' : ['<Plug>(coc-references)'              , 'references'],
      \ 's' : [':CocList -I symbols'                 , 'references'],
      \ 'S' : [':CocList snippets'                   , 'snippets'],
      \ 't' : ['<Plug>(coc-type-definition)'         , 'type definition'],
      \ 'u' : [':CocListResume'                      , 'resume list'],
      \ 'U' : [':CocUpdate'                          , 'update CoC'],
      \ 'v' : [':Vista!!'                            , 'tag viewer'],
      \ 'z' : [':CocDisable'                         , 'disable CoC'],
      \ 'Z' : [':CocEnable'                          , 'enable CoC'],
      \ }

" t is for terminal
let g:which_key_map.t = {
      \ 'name' : '+terminal' ,
      \ ';' : [':FloatermNew --wintype=popup --height=6'        , 'terminal'],
      \ 'f' : [':FloatermNew fzf'                               , 'fzf'],
      \ 'g' : [':FloatermNew lazygit'                           , 'git'],
      \ 'd' : [':FloatermNew lazydocker'                        , 'docker'],
      \ 'n' : [':FloatermNew node'                              , 'node'],
      \ 'N' : [':FloatermNew nnn'                               , 'nnn'],
      \ 'p' : [':FloatermNew python'                            , 'python'],
      \ 'r' : [':FloatermNew ranger'                            , 'ranger'],
      \ 't' : [':FloatermToggle'                                , 'toggle'],
      \ 'y' : [':FloatermNew ytop'                              , 'ytop'],
      \ 's' : [':FloatermNew ncdu'                              , 'ncdu'],
      \ }

" w is for wiki
let g:which_key_map.w = {
      \ 'name' : '+wiki' ,
      \ 'w' : ['<Plug>VimwikiIndex'                              , 'ncdu'],
      \ 'n' : ['<plug>(wiki-open)'                              , 'ncdu'],
      \ 'j' : ['<plug>(wiki-journal)'                              , 'ncdu'],
      \ 'R' : ['<plug>(wiki-reload)'                              , 'ncdu'],
      \ 'c' : ['<plug>(wiki-code-run)'                              , 'ncdu'],
      \ 'b' : ['<plug>(wiki-graph-find-backlinks)'                              , 'ncdu'],
      \ 'g' : ['<plug>(wiki-graph-in)'                              , 'ncdu'],
      \ 'G' : ['<plug>(wiki-graph-out)'                              , 'ncdu'],
      \ 'l' : ['<plug>(wiki-link-toggle)'                              , 'ncdu'],
      \ 'd' : ['<plug>(wiki-page-delete)'                              , 'ncdu'],
      \ 'r' : ['<plug>(wiki-page-rename)'                              , 'ncdu'],
      \ 't' : ['<plug>(wiki-page-toc)'                              , 'ncdu'],
      \ 'T' : ['<plug>(wiki-page-toc-local)'                              , 'ncdu'],
      \ 'e' : ['<plug>(wiki-export)'                              , 'ncdu'],
      \ 'u' : ['<plug>(wiki-list-uniq)'                              , 'ncdu'],
      \ 'U' : ['<plug>(wiki-list-uniq-local)'                              , 'ncdu'],
      \ }

" Global
" <Plug>VimwikiIndex
" <Plug>VimwikiTabIndex
" <Plug>VimwikiUISelect
" <Plug>VimwikiDiaryIndex
" <Plug>VimwikiMakeDiaryNote
" <Plug>VimwikiTabMakeDiaryNote
" <Plug>VimwikiMakeYesterdayDiaryNote
" <Plug>VimwikiMakeTomorrowDiaryNote
"
" " Local
" <Plug>Vimwiki2HTML
" <Plug>Vimwiki2HTMLBrowse
" <Plug>VimwikiDiaryGenerateLinks
" <Plug>VimwikiFollowLink
" <Plug>VimwikiSplitLink
" <Plug>VimwikiVSplitLink
" <Plug>VimwikiTabnewLink
" <Plug>VimwikiGoBackLink
" <Plug>VimwikiNextLink
" <Plug>VimwikiPrevLink
" <Plug>VimwikiGoto
" <Plug>VimwikiDeleteLink
" <Plug>VimwikiRenameLink
" <Plug>VimwikiAddHeaderLevel

" Register which key map
call which_key#register('<Space>', "g:which_key_map")
    endif
" }}}

" winmanager {{{
    if isdirectory(expand(plugdir."/winmanager")) && isdirectory(expand(plugdir."/bufexplorer")) && isdirectory(expand(plugdir."/taglist.vim"))
        """"""""""""""""""""""""""""""
        " winManager setting
        """"""""""""""""""""""""""""""
        let g:winManagerWindowLayout = "FileExplorer,BufExplorer|TagList"
        let g:winManagerWidth = 30
        let g:defaultExplorer = 0
        nmap <C-W><C-F> :FirstExplorerWindow<cr>
        nmap <C-W><C-B> :BottomExplorerWindow<cr>
        nmap <silent> <leader>wm :WMToggle<cr>
    endif
    " }}}

"" cscope {{{
"    " exec '!cscope add "'. $VIM .'\vim.out"'
"    " 首先，您需要验证代码是C还是C ++。
"    " 其次，cscope -Rbkq在代码项目下执行命令以生成cscope.out文件。
"    " Autoloading Cscope Database  "https://github.com/SpaceVim/SpaceVim/issues/1692
"    function! LoadCscope()
"      let db = findfile("cscope.out", ".;")
"      if (!empty(db))
"        echo "有db"
"        let path = strpart(db, 0, match(db, "/cscope.out$"))
"        "echo "db=" . db . "path=" . path
"        set nocscopeverbose " suppress 'duplicate connection' error
"        exe "cs add " . db . " " . path
"        set cscopeverbose
"      " else add the database pointed to by environment variable 
"      elseif $CSCOPE_DB != "" 
"        echo "没有db"
"        cs add $CSCOPE_DB
"      endif
"    endfunction
"    "au BufEnter /* call LoadCscope()
"    "：wcd $VIM
"    "au BufEnter /* call LoadCscope()
"" }}}
"
" Gtags-cscope {{{
    "GNU GLOBAL即gtags，含有gtags、global两个可执行文件或说两个命令：gtags(管理员命令执行gtags -v)→生成索引文件。global(global -u)→找到标识符。
    "https://zhuanlan.zhihu.com/p/36279445
    let $GTAGSCONF = 'D:\Portable/glo663wb(gtags)/share/gtags/gtags.conf'      "$GTAGSCONF必须设置，否则会找不到 native-pygments 和 language map 的定义，
    "export GTAGSCONF='D:\Portable/glo663wb(gtags)/share/gtags/gtags.conf'
    let $GTAGSLABEL = 'native-pygments'               "$GTAGSLABEL 告诉 gtags 默认 C/C++/Java 等六种原生支持的代码直接使用 gtags 本地分析器，而其他语言使用 pygments 模块。
    "export GTAGSLABEL='native-pygments'

    "exec 'cd ' . fnameescape($VIM)
    ":cd $VIM
    " Configure
    " ---------
    " You can use the following variables in $HOME/.vimrc.
    "
    " To use the default key/mouse mapping:
    let GtagsCscope_Auto_Map = 1
    " To ignore letter case when searching:
    let GtagsCscope_Ignore_Case = 1
    " To use absolute path name:
    "       let GtagsCscope_Absolute_Path = 1
    " To deterring interruption:
    let GtagsCscope_Keep_Alive = 1
    " If you hope auto loading:
    let GtagsCscope_Auto_Load = 1                 "有启动cmd。这个开关没打开，let GtagsCscope_Auto_Map = 1这个设置就不起作用，即就没有这些键绑定设置。
    " To use 'vim -t ', ':tag' and '<C-]>'
    "	set cscopetag
     
    " 上面是自动连接GTAGS，下面是手动的：
    "https://vi.stackexchange.com/questions/4991/using-gnu-global-and-gtags-cscope-in-vim
    "https://www.cnblogs.com/cascle/p/5148389.html
    " set cscopetag              "使用 cscope 作为 tags 命令
    " set csprg=gtags-cscope     "使用 gtags-cscope 代替 cscope。没有这条设置,cs add GTAGS时报“E609: Cscope 错误: cscope: cannot read file version from file D:\Vim\GTAGS”错误。
    " cs add GTAGS               "将标志文件GTAGS添加到cs。
" }}}

" vimgrep {{{
    if executable("rg")
        set grepprg=rg\ --vimgrep\
        set grepformat=%f:%l:%c:%m
        "https://vim.fandom.com/wiki/Find_in_files_within_Vim
        map <F4> :execute "vimgrep /" . expand("<cword>") . "/j **" <Bar> cw<CR>
    endif
" }}}

" FZF {{{
    if isdirectory(expand(plugdir."/fzf"))&& isdirectory(expand(plugdir."/fzf.vim"))
"        source ~/vimrc/7-fzf.vim
"https://github.com/junegunn/dotfiles/blob/master/vimrc
let $FZF_DEFAULT_OPTS .= ' --inline-info'

" All files
command! -nargs=? -complete=dir AF
  \ call fzf#run(fzf#wrap(fzf#vim#with_preview({
  \   'source': 'fd --type f --hidden --follow --exclude .git --no-ignore . '.expand(<q-args>)
  \ })))

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Terminal buffer options for fzf
autocmd! FileType fzf
autocmd  FileType fzf set noshowmode noruler nonu

if exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
else
  let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }
endif

" nnoremap <silent> <Leader><Leader> :Files<CR>
nnoremap <silent> <expr> <Leader><Leader> (expand('%') =~ 'NERD_tree' ? "\<c-w>\<c-w>" : '').":Files\<cr>"
nnoremap <silent> <Leader>C        :Colors<CR>
nnoremap <silent> <Leader><Enter>  :Buffers<CR>
nnoremap <silent> <Leader>L        :Lines<CR>
nnoremap <silent> <Leader>ag       :Ag <C-R><C-W><CR>
nnoremap <silent> <Leader>AG       :Ag <C-R><C-A><CR>
xnoremap <silent> <Leader>ag       y:Ag <C-R>"<CR>
nnoremap <silent> <Leader>`        :Marks<CR>
" nnoremap <silent> q: :History:<CR>
" nnoremap <silent> q/ :History/<CR>

inoremap <expr> <c-x><c-t> fzf#complete('tmuxwords.rb --all-but-current --scroll 500 --min 5')
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
inoremap <expr> <c-x><c-d> fzf#vim#complete#path('blsd')
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" nmap <leader><tab> <plug>(fzf-maps-n)
" xmap <leader><tab> <plug>(fzf-maps-x)
" omap <leader><tab> <plug>(fzf-maps-o)

function! s:plug_help_sink(line)
  let dir = g:plugs[a:line].dir
  for pat in ['doc/*.txt', 'README.md']
    let match = get(split(globpath(dir, pat), "\n"), 0, '')
    if len(match)
      execute 'tabedit' match
      return
    endif
  endfor
  tabnew
  execute 'Explore' dir
endfunction

command! PlugHelp call fzf#run(fzf#wrap({
  \ 'source': sort(keys(g:plugs)),
  \ 'sink':   function('s:plug_help_sink')}))

function! RipgrepFzf(query, fullscreen)
  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
  let initial_command = printf(command_fmt, shellescape(a:query))
  let reload_command = printf(command_fmt, '{q}')
  let options = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
  let options = fzf#vim#with_preview(options, 'right', 'ctrl-/')
  call fzf#vim#grep(initial_command, 1, options, a:fullscreen)
endfunction

command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)

command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   "rg --column --line-number --no-heading --color=always --smart-case -- ".shellescape(<q-args>), 1,
  \   fzf#vim#with_preview('right', 'ctrl-/'), <bang>0)

command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>, fzf#vim#with_preview('right', 'ctrl-/'), <bang>0)


"https://github.com/ChristianChiarulli/nvim/tree/master/plug-config
"" This is the default extra key bindings
"let g:fzf_action = {
"  \ 'ctrl-t': 'tab split',
"  \ 'ctrl-x': 'split',
"  \ 'ctrl-v': 'vsplit' }
"
"" Enable per-command history.
"" CTRL-N and CTRL-P will be automatically bound to next-history and
"" previous-history instead of down and up. If you don't like the change,
"" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
"let g:fzf_history_dir = '~/.local/share/fzf-history'
"let g:fzf_buffers_jump = 1
"
"" map <C-f> :Files<CR>
"" map <leader>b :Buffers<CR>
"" nnoremap <leader>g :Rg<CR>
"" nnoremap <leader>t :Tags<CR>
"" nnoremap <leader>m :Marks<CR>
"
"
"let g:fzf_tags_command = 'ctags -R'
"" Border color
"let g:fzf_layout = {'up':'~90%', 'window': { 'width': 0.8, 'height': 0.8,'yoffset':0.5,'xoffset': 0.5, 'highlight': 'Todo', 'border': 'sharp' } }
"
"let $FZF_DEFAULT_OPTS = '--layout=reverse --inline-info'
"let $FZF_DEFAULT_COMMAND="rg --files --hidden --glob '!.git/**'"
""-g '!{node_modules,.git}'
"
"" Customize fzf colors to match your color scheme
"let g:fzf_colors =
"\ { 'fg':      ['fg', 'Normal'],
"  \ 'bg':      ['bg', 'Normal'],
"  \ 'hl':      ['fg', 'Comment'],
"  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
"  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
"  \ 'hl+':     ['fg', 'Statement'],
"  \ 'info':    ['fg', 'PreProc'],
"  \ 'border':  ['fg', 'Ignore'],
"  \ 'prompt':  ['fg', 'Conditional'],
"  \ 'pointer': ['fg', 'Exception'],
"  \ 'marker':  ['fg', 'Keyword'],
"  \ 'spinner': ['fg', 'Label'],
"  \ 'header':  ['fg', 'Comment'] }
"
""Get Files
"command! -bang -nargs=? -complete=dir Files
"    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--inline-info']}), <bang>0)
"
"
"" Get text in files with Rg
"" command! -bang -nargs=* Rg
""   \ call fzf#vim#grep(
""   \   "rg --column --line-number --no-heading --color=always --smart-case --glob '!.git/**' ".shellescape(<q-args>), 1,
"
" " Make Ripgrep ONLY search file contents and not filenames
"command! -bang -nargs=* Rg
"  \ call fzf#vim#grep(
"  \   'rg --column --line-number --hidden --smart-case --no-heading --color=always '.shellescape(<q-args>), 1,
"  \   <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')
"  \           : fzf#vim#with_preview({'options': '--delimiter : --nth 4.. -e'}, 'right:50%', '?'),
"  \   <bang>0)
"
"" Ripgrep advanced
"function! RipgrepFzf(query, fullscreen)
"  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
"  let initial_command = printf(command_fmt, shellescape(a:query))
"  let reload_command = printf(command_fmt, '{q}')
"  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
"  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
"endfunction
"
"command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)
"
"" Git grep
"command! -bang -nargs=* GGrep
"  \ call fzf#vim#grep(
"  \   'git grep --line-number '.shellescape(<q-args>), 0,
"  \   fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)
    endif
" }}}

" GoLang {{{
        let g:go_highlight_functions = 1
        let g:go_highlight_methods = 1
        let g:go_highlight_structs = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_build_constraints = 1
        let g:go_fmt_command = "goimports"
        let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
        let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go'] }
        au FileType go nmap <Leader>s <Plug>(go-implements)
        au FileType go nmap <Leader>i <Plug>(go-info)
        au FileType go nmap <Leader>e <Plug>(go-rename)
        au FileType go nmap <leader>r <Plug>(go-run)
        au FileType go nmap <leader>b <Plug>(go-build)
        au FileType go nmap <leader>t <Plug>(go-test)
        au FileType go nmap <Leader>gd <Plug>(go-doc)
        au FileType go nmap <Leader>gv <Plug>(go-doc-vertical)
        au FileType go nmap <leader>co <Plug>(go-coverage)
" }}}

" TextObj Sentence {{{
        augroup textobj_sentence
          autocmd!
          autocmd FileType markdown call textobj#sentence#init()
          autocmd FileType textile call textobj#sentence#init()
          autocmd FileType text call textobj#sentence#init()
        augroup END
" }}}

" TextObj Quote {{{
        augroup textobj_quote
            autocmd!
            autocmd FileType markdown call textobj#quote#init()
            autocmd FileType textile call textobj#quote#init()
            autocmd FileType text call textobj#quote#init({'educate': 0})
        augroup END
" }}}

" PIV {{{
    if isdirectory(expand(plugdir."/PIV"))
        let g:DisableAutoPHPFolding = 0
        let g:PIVAutoClose = 0
    endif
" }}}

" Misc {{{
    if isdirectory(expand(plugdir."/nerdtree"))
        let g:NERDShutUp=1
    endif
    if isdirectory(expand(plugdir."/matchit.zip"))
        let b:match_ignorecase = 1
    endif
" }}}

" OmniComplete {{{
        if has("autocmd") && exists("+omnifunc")
            autocmd Filetype *
                \if &omnifunc == "" |
                \setlocal omnifunc=syntaxcomplete#Complete |
                \endif
        endif

        hi Pmenu  guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
        hi PmenuSbar  guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
        hi PmenuThumb  guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

        " Some convenient mappings
        "inoremap <expr> <Esc>      pumvisible() ? "\<C-e>" : "\<Esc>"
        if exists('g:spf13_map_cr_omni_complete')
            inoremap <expr> <CR>     pumvisible() ? "\<C-y>" : "\<CR>"
        endif
        inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
        inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
        inoremap <expr> <C-d>      pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
        inoremap <expr> <C-u>      pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

        " Automatically open and close the popup menu / preview window
        au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
        set completeopt=menu,preview,longest
" }}}

"    " Ctags {{{
"        set tags=./tags;/,~/.vimtags
"
"        " Make tags placed in .git/tags file available in all levels of a repository
"        let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
"        if gitroot != ''
"            let &tags = &tags . ',' . gitroot . '/.git/tags'
"        endif
"    " }}}

" AutoCloseTag {{{
    " Make it so AutoCloseTag works for xml and xhtml files as well
    au FileType xhtml,xml ru ftplugin/html/autoclosetag.vim
    nmap <Leader>ac <Plug>ToggleAutoCloseMappings
" }}}

" SnipMate {{{
    " Setting the author var
    " If forking, please overwrite in your .vimrc.local file
    let g:snips_author = 'Steve Francia <steve.francia@gmail.com>'
" }}}

" NerdTree {{{
    if isdirectory(expand(plugdir."/nerdtree"))
        map <C-e> <plug>NERDTreeTabsToggle<CR>
        map <leader>e :NERDTreeFind<CR>
        nmap <leader>nt :NERDTreeFind<CR>

        let NERDTreeShowBookmarks=1
        let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
        let NERDTreeChDirMode=0
        let NERDTreeQuitOnOpen=1
        let NERDTreeMouseMode=2
        let NERDTreeShowHidden=1
        let NERDTreeKeepTreeInNewTab=1
        let g:nerdtree_tabs_open_on_gui_startup=0
    endif
" }}}

" Tabularize {{{
    if isdirectory(expand(plugdir."/tabular"))
        nmap <Leader>a& :Tabularize /&<CR>
        vmap <Leader>a& :Tabularize /&<CR>
        nmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
        vmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
        nmap <Leader>a=> :Tabularize /=><CR>
        vmap <Leader>a=> :Tabularize /=><CR>
        nmap <Leader>a: :Tabularize /:<CR>
        vmap <Leader>a: :Tabularize /:<CR>
        nmap <Leader>a:: :Tabularize /:\zs<CR>
        vmap <Leader>a:: :Tabularize /:\zs<CR>
        nmap <Leader>a, :Tabularize /,<CR>
        vmap <Leader>a, :Tabularize /,<CR>
        nmap <Leader>a,, :Tabularize /,\zs<CR>
        vmap <Leader>a,, :Tabularize /,\zs<CR>
        nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
        vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
    endif
" }}}

" Session List {{{
    set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
    if isdirectory(expand(plugdir."/sessionman.vim/"))
        nmap <leader>sl :SessionList<CR>
        nmap <leader>ss :SessionSave<CR>
        nmap <leader>sc :SessionClose<CR>
    endif
" }}}

" JSON {{{
    nmap <leader>jt <Esc>:%!python -m json.tool<CR><Esc>:set filetype=json<CR>
    let g:vim_json_syntax_conceal = 0
" }}}

" PyMode {{{
    " Disable if python support not present
    if !has('python') && !has('python3')
        let g:pymode = 0
    endif

    if isdirectory(expand(plugdir."/python-mode"))
        let g:pymode_lint_checkers = ['pyflakes']
        let g:pymode_trim_whitespaces = 0
        let g:pymode_options = 0
        let g:pymode_rope = 0
    endif
" }}}

" ctrlp {{{
    if isdirectory(expand(plugdir."/ctrlp.vim/"))
        let g:ctrlp_working_path_mode = 'ra'
        "nnoremap <silent> <D-t> :CtrlP<CR>
        "nnoremap <silent> <D-r> :CtrlPMRU<CR>
        nnoremap <silent> <Leader>p :CtrlP<CR>
        nnoremap <silent> <Leader>f :CtrlPMRU<CR>
        nnoremap <silent> <Leader>b :CtrlPBuffer<CR>
        "nmap <Leader>b :CtrlPBuffer<CR>                  "nmap这样绑定不行
        let g:ctrlp_custom_ignore = {
            \ 'dir':  '\.git$\|\.hg$\|\.svn$',
            \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }

        if executable('ag')
            let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
        elseif executable('ack-grep')
            let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
        elseif executable('ack')
            let s:ctrlp_fallback = 'ack %s --nocolor -f'
        " On Windows use "dir" as fallback command.
        elseif g:windows
            let s:ctrlp_fallback = 'dir %s /-n /b /s /a-d'
        else
            let s:ctrlp_fallback = 'find %s -type f'
        endif
        if exists("g:ctrlp_user_command")
            unlet g:ctrlp_user_command
        endif
        let g:ctrlp_user_command = {
            \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
                \ 2: ['.hg', 'hg --cwd %s locate -I .'],
            \ },
            \ 'fallback': s:ctrlp_fallback
        \ }

        if isdirectory(expand(plugdir."/ctrlp-funky/"))
            " CtrlP extensions
            let g:ctrlp_extensions = ['funky']

            "funky
            nnoremap <Leader>fu :CtrlPFunky<Cr>
        endif
    endif
"}}}

" TagBar {{{
    if isdirectory(expand(plugdir."/tagbar/"))
        nnoremap <silent> <leader>tt :TagbarToggle<CR>
    endif
"}}}

" Rainbow {{{
    if isdirectory(expand(plugdir."/rainbow/"))
        let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle
    endif
"}}}

" Fugitive {{{
    if isdirectory(expand(plugdir."/vim-fugitive/"))
        nnoremap <silent> <leader>gs :Gstatus<CR>
        nnoremap <silent> <leader>gd :Gdiff<CR>
        nnoremap <silent> <leader>gc :Gcommit<CR>
        nnoremap <silent> <leader>gb :Gblame<CR>
        nnoremap <silent> <leader>gl :Glog<CR>
        nnoremap <silent> <leader>gp :Git push<CR>
        nnoremap <silent> <leader>gr :Gread<CR>
        nnoremap <silent> <leader>gw :Gwrite<CR>
        nnoremap <silent> <leader>ge :Gedit<CR>
        " Mnemonic _i_nteractive
        nnoremap <silent> <leader>gi :Git add -p %<CR>
        nnoremap <silent> <leader>gg :SignifyToggle<CR>
    endif
"}}}

" YouCompleteMe {{{
        let g:acp_enableAtStartup = 0

        " enable completion from tags
        let g:ycm_collect_identifiers_from_tags_files = 1

        " remap Ultisnips for compatibility for YCM
        let g:UltiSnipsExpandTrigger = '<C-j>'
        let g:UltiSnipsJumpForwardTrigger = '<C-j>'
        let g:UltiSnipsJumpBackwardTrigger = '<C-k>'

        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

        " Haskell post write lint and check with ghcmod
        " $ `cabal install ghcmod` if missing and ensure
        " ~/.cabal/bin is in your $PATH.
        if !executable("ghcmod")
            autocmd BufWritePost *.hs GhcModCheckAndLintAsync
        endif

        " For snippet_complete marker.
        if !exists("g:spf13_no_conceal")
            if has('conceal')
                set conceallevel=2 concealcursor=i
            endif
        endif

        " Disable the neosnippet preview candidate window
        " When enabled, there can be too much visual noise
        " especially when splits are used.
        set completeopt-=preview
" }}}

" neocomplete {{{
        let g:acp_enableAtStartup = 0
        let g:neocomplete#enable_at_startup = 1
        let g:neocomplete#enable_smart_case = 1
        let g:neocomplete#enable_auto_delimiter = 1
        let g:neocomplete#max_list = 15
        let g:neocomplete#force_overwrite_completefunc = 1


        " Define dictionary.
        let g:neocomplete#sources#dictionary#dictionaries = {
                    \ 'default' : '',
                    \ 'vimshell' : $HOME.'/.vimshell_hist',
                    \ 'scheme' : $HOME.'/.gosh_completions'
                    \ }

        " Define keyword.
        if !exists('g:neocomplete#keyword_patterns')
            let g:neocomplete#keyword_patterns = {}
        endif
        let g:neocomplete#keyword_patterns['default'] = '\h\w*'

        " Plugin key-mappings {{{
            " These two lines conflict with the default digraph mapping of <C-K>
            if !exists('g:spf13_no_neosnippet_expand')
                imap <C-k> <Plug>(neosnippet_expand_or_jump)
                smap <C-k> <Plug>(neosnippet_expand_or_jump)
            endif
            if exists('g:spf13_noninvasive_completion')
                inoremap <CR> <CR>
                " <ESC> takes you out of insert mode
                inoremap <expr> <Esc>   pumvisible() ? "\<C-y>\<Esc>" : "\<Esc>"
                " <CR> accepts first, then sends the <CR>
                inoremap <expr> <CR>    pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
                " <Down> and <Up> cycle like <Tab> and <S-Tab>
                inoremap <expr> <Down>  pumvisible() ? "\<C-n>" : "\<Down>"
                inoremap <expr> <Up>    pumvisible() ? "\<C-p>" : "\<Up>"
                " Jump up and down the list
                inoremap <expr> <C-d>   pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
                inoremap <expr> <C-u>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"
            else
                " <C-k> Complete Snippet
                " <C-k> Jump to next snippet point
                imap <silent><expr><C-k> neosnippet#expandable() ?
                            \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
                            \ "\<C-e>" : "\<Plug>(neosnippet_expand_or_jump)")
                smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)

                inoremap <expr><C-g> neocomplete#undo_completion()
                inoremap <expr><C-l> neocomplete#complete_common_string()
                "inoremap <expr><CR> neocomplete#complete_common_string()

                " <CR>: close popup
                " <s-CR>: close popup and save indent.
                inoremap <expr><s-CR> pumvisible() ? neocomplete#smart_close_popup()."\<CR>" : "\<CR>"

                function! CleverCr()
                    if pumvisible()
                        if neosnippet#expandable()
                            let exp = "\<Plug>(neosnippet_expand)"
                            return exp . neocomplete#smart_close_popup()
                        else
                            return neocomplete#smart_close_popup()
                        endif
                    else
                        return "\<CR>"
                    endif
                endfunction

                " <CR> close popup and save indent or expand snippet
                imap <expr> <CR> CleverCr()
                " <C-h>, <BS>: close popup and delete backword char.
                inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
                inoremap <expr><C-y> neocomplete#smart_close_popup()
            endif
            " <TAB>: completion.
            inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<TAB>"

            " Courtesy of Matteo Cavalleri

            function! CleverTab()
                if pumvisible()
                    return "\<C-n>"
                endif
                let substr = strpart(getline('.'), 0, col('.') - 1)
                let substr = matchstr(substr, '[^ \t]*$')
                if strlen(substr) == 0
                    " nothing to match on empty string
                    return "\<Tab>"
                else
                    " existing text matching
                    if neosnippet#expandable_or_jumpable()
                        return "\<Plug>(neosnippet_expand_or_jump)"
                    else
                        return neocomplete#start_manual_complete()
                    endif
                endif
            endfunction

            imap <expr> <Tab> CleverTab()
        " }}}

        " Enable heavy omni completion.
        if !exists('g:neocomplete#sources#omni#input_patterns')
            let g:neocomplete#sources#omni#input_patterns = {}
        endif
        let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
" }}}

" neocomplcache {{{
        let g:acp_enableAtStartup = 0
        let g:neocomplcache_enable_at_startup = 1
        let g:neocomplcache_enable_camel_case_completion = 1
        let g:neocomplcache_enable_smart_case = 1
        let g:neocomplcache_enable_underbar_completion = 1
        let g:neocomplcache_enable_auto_delimiter = 1
        let g:neocomplcache_max_list = 15
        let g:neocomplcache_force_overwrite_completefunc = 1

        " Define dictionary.
        let g:neocomplcache_dictionary_filetype_lists = {
                    \ 'default' : '',
                    \ 'vimshell' : $HOME.'/.vimshell_hist',
                    \ 'scheme' : $HOME.'/.gosh_completions'
                    \ }

        " Define keyword.
        if !exists('g:neocomplcache_keyword_patterns')
            let g:neocomplcache_keyword_patterns = {}
        endif
        let g:neocomplcache_keyword_patterns._ = '\h\w*'

        " Plugin key-mappings {{{
            " These two lines conflict with the default digraph mapping of <C-K>
            imap <C-k> <Plug>(neosnippet_expand_or_jump)
            smap <C-k> <Plug>(neosnippet_expand_or_jump)
            if exists('g:spf13_noninvasive_completion')
                inoremap <CR> <CR>
                " <ESC> takes you out of insert mode
                inoremap <expr> <Esc>   pumvisible() ? "\<C-y>\<Esc>" : "\<Esc>"
                " <CR> accepts first, then sends the <CR>
                inoremap <expr> <CR>    pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
                " <Down> and <Up> cycle like <Tab> and <S-Tab>
                inoremap <expr> <Down>  pumvisible() ? "\<C-n>" : "\<Down>"
                inoremap <expr> <Up>    pumvisible() ? "\<C-p>" : "\<Up>"
                " Jump up and down the list
                inoremap <expr> <C-d>   pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
                inoremap <expr> <C-u>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"
            else
                imap <silent><expr><C-k> neosnippet#expandable() ?
                            \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
                            \ "\<C-e>" : "\<Plug>(neosnippet_expand_or_jump)")
                smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)

                inoremap <expr><C-g> neocomplcache#undo_completion()
                inoremap <expr><C-l> neocomplcache#complete_common_string()
                "inoremap <expr><CR> neocomplcache#complete_common_string()

                function! CleverCr()
                    if pumvisible()
                        if neosnippet#expandable()
                            let exp = "\<Plug>(neosnippet_expand)"
                            return exp . neocomplcache#close_popup()
                        else
                            return neocomplcache#close_popup()
                        endif
                    else
                        return "\<CR>"
                    endif
                endfunction

                " <CR> close popup and save indent or expand snippet
                imap <expr> <CR> CleverCr()

                " <CR>: close popup
                " <s-CR>: close popup and save indent.
                inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup()."\<CR>" : "\<CR>"
                "inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>"

                " <C-h>, <BS>: close popup and delete backword char.
                inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
                inoremap <expr><C-y> neocomplcache#close_popup()
            endif
            " <TAB>: completion.
            inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<TAB>"
        " }}}

        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

        " Enable heavy omni completion.
        if !exists('g:neocomplcache_omni_patterns')
            let g:neocomplcache_omni_patterns = {}
        endif
        let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
        let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
        let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
        let g:neocomplcache_omni_patterns.go = '\h\w*\.\?'
" }}}

" Normal Vim omni-completion {{{
" To disable omni complete, add the following to your .vimrc.before.local file:
        " Enable omni-completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

" }}}

" Snippets {{{

        " Use honza's snippets.
        let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'

        " Enable neosnippet snipmate compatibility mode
        let g:neosnippet#enable_snipmate_compatibility = 1

        " For snippet_complete marker.
        if !exists("g:spf13_no_conceal")
            if has('conceal')
                set conceallevel=2 concealcursor=i
            endif
        endif

        " Enable neosnippets when using go
        let g:go_snippet_engine = "neosnippet"

        " Disable the neosnippet preview candidate window
        " When enabled, there can be too much visual noise
        " especially when splits are used.
        set completeopt-=preview
" }}}

" ghcmod {{{
    " FIXME: Isn't this for Syntastic to handle?
    " Haskell post write lint and check with ghcmod
    " $ `cabal install ghcmod` if missing and ensure
    " ~/.cabal/bin is in your $PATH.
    if !executable("ghcmod")
        autocmd BufWritePost *.hs GhcModCheckAndLintAsync
    endif
" }}}

" UndoTree {{{
    if isdirectory(expand(plugdir."/undotree/"))
        nnoremap <Leader>u :UndotreeToggle<CR>
        " If undotree is opened, it is likely one wants to interact with it.
        let g:undotree_SetFocusWhenToggle=1
    endif
" }}}

" indent_guides {{{
    if isdirectory(expand(plugdir."/vim-indent-guides/"))
        let g:indent_guides_start_level = 2
        let g:indent_guides_guide_size = 1
        let g:indent_guides_enable_on_vim_startup = 1
    endif
" }}}

" Wildfire {{{
let g:wildfire_objects = {
            \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
            \ "html,xml" : ["at"],
            \ }
" }}}

" vim-airline {{{
    " Set configuration options for the statusline plugin vim-airline.
    " Use the powerline theme and optionally enable powerline symbols.
    " To use the symbols , , , , , , and .in the statusline
    " segments add the following to your .vimrc.before.local file:
    "   let g:airline_powerline_fonts=1
    " If the previous symbols do not render for you then install a
    " powerline enabled font.

    " See `:echo g:airline_theme_map` for some more choices
    " Default in terminal vim is 'dark'
    if isdirectory(expand(plugdir."/vim-airline-themes/"))
        if !exists('g:airline_theme')
            "let g:airline_theme = 'solarized'
        endif
        if !exists('g:airline_powerline_fonts')
            " Use the default set of separators with a few customizations
            "let g:airline_left_sep='›'  " Slightly fancier than '>'
            "let g:airline_right_sep='‹' " Slightly fancier than '<'
            let g:airline_left_sep = ''             " ''
            let g:airline_left_alt_sep = '|'        " ''
            let g:airline_right_sep = ''
            let g:airline_right_alt_sep = '|'       " ''
        endif
        let g:airline#extensions#tabline#enabled = 1
        let g:airline#extensions#tabline#buffer_nr_show = 1
    endif

" }}}

"" vim-devicons {{{
"    " loading the plugin
"    let g:webdevicons_enable = 1
"    " adding the flags to NERDTree
"    "let g:webdevicons_enable_nerdtree = 1
"    " adding to vim-airline's tabline
"    let g:webdevicons_enable_airline_tabline = 1
"    " adding to vim-airline's statusline
"    let g:webdevicons_enable_airline_statusline = 1
"    " ctrlp glyphs
"    let g:webdevicons_enable_ctrlp = 1
"" }}}

" }}}

" GUI Settings {{{

    " GVIM- (here instead of .gvimrc)
    if has('gui_running')
        " 如下自加
        winpos 235 235                          "启动位置
        set lines=25 columns=108                "窗口大小
        "设置gvim隐藏菜单栏，工具栏，滚动条
        "set guioptions-=m  "remove menu bar
        set guioptions-=T  "remove toolbar
        set guioptions-=r  "remove right-hand scroll bar
        set guioptions-=L  "remove left-hand scroll bar

        set guioptions-=T           " Remove the toolbar
        set lines=40                " 40 lines of text instead of 24
        if !exists("g:spf13_no_big_font")
            if g:linux && has("gui_running")
                set guifont=Andale\ Mono\ Regular\ 12,Menlo\ Regular\ 11,Consolas\ Regular\ 12,Courier\ New\ Regular\ 14
            elseif g:osx && has("gui_running")
                set guifont=Andale\ Mono\ Regular:h12,Menlo\ Regular:h11,Consolas\ Regular:h12,Courier\ New\ Regular:h14
            elseif g:windows && has("gui_running")
                set guifont=DejaVuSansMono_Nerd_Font_Mono:h9,oAndale_Mono:h9,Menlo:h9,Consolas:h9,Courier_New:h9
            endif
        endif
    else
        if &term == 'xterm' || &term == 'screen'
            set t_Co=256            " Enable 256 colors to stop the CSApprox warning and make xterm vim shine
        endif
        "set term=builtin_ansi       " Make arrow and other keys work
    endif

" }}}

" Functions {{{
" ...
" }}}
